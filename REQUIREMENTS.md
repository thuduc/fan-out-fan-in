Come up with a design based on the following requirements.
- The xml request (see request.xml for example) contains one or more groups, where each group contains one or more valuations. Each valuation represents an evaluation of a financial instrument (e.g., home loan). Each valuation is called a task.  The ordering of the groups is important since group 2 tasks processing cannot start until all of group 1's tasks finished processing, since the valuation results of group 1's tasks will be used by group 2's tasks. In other words, the processing of group N's tasks cannot begin until group N-1's tasks complete. A xml request orchestrator microservice will parse the xml request to create multiple groups, where each group contains a set of smaller task xml requests (each generated from the main xml request and prior group's tasks results).
- For example, if an xml request has 3 groups and each group contains 10 tasks, the total number of task xml requests will be 30. Group 1's tasks will be processed first until completion; then the xml requests for group 2 tasks will be generated (using the results from group 1's tasks) and then processed until completion; then the xml requests for group 3 tasks will be generated (using the results from group 2's tasks) and then processed until completion. After all groups of the xml request have been processes, the results will be assembled by the request orchestrator microservice.
- I want you to come up with a design using redis (using of redis streams for service communication and state management; and redis cache for caching of xml requests and data since these can be large) so that vnapi (the main orchestrator) of the application will be running in AWS fargate as a microservice, built using Node.js. vnapi will monitor a request redis stream for new requests. When a new request comes it, vnapi will asynchronously invoke vnvs (the request orchestrator microservice) to handle the request (note that the xml request itself need to be stored in redis cache since it can be large, up to 10MB). If there are 10 new requests on the redis stream, vnapi will launch 10 vnvs microservices asynchonously - each vnvs microservice will handle 1 request. We will use AWS Lambda function for vnvs.
- As mentioned previously, vnvs will process each group in order until completion. For each group, vnvs will create the individual task xml requests, store these individual task xml requests in redis cache (since they can be large), then use another redis stream to notify vnas (the task xml request lambda microservice) to process the request, which then will save the results of the task to Redis upon completion.
- Each vnvs (lambda using Python) will need to continue to monitor each group until completion (via a redis stream counter?) before creating (the task request xmls) and executing the next group's tasks. vnvs will use redis streams and cache to communicate/notify other microservices (e.g., vnas), and also to retrieve the results from the redis cache. Upon completion of all groups, vnvs will then retrieve all the task results from cache, build the xml response for the xml request, store the response in redis, then notify the caller that the xml request processing is done. Think hard to come up with a modular and clean design using redis
- Try to simply the use of redis streams: usage of global streams of per group streams to simplify design, implementation, and management
- Note the use of Redis cache for caching of xml requests, data, and task results. Do not use redis streams to store xml requests and data. Use references to redis cache
- Tech stack summary:
  - vnapi: Node.js running in AWS ECS Fargate
  - vnvs: Python running in Lambda
  - vnas: Python running in Lambda
- Store the design to a file name DESIGN.md
- Do not create any code. Only come up with a detailed design.
